<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‹è½½æµ‹è¯•</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            font-size: 16px;
        }
        button:hover {
            background: #1177bb;
        }
        .log {
            background: #252526;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            white-space: pre-wrap;
        }
        .success { color: #4ec9b0; }
        .error { color: #f48771; }
        input[type="file"] {
            margin: 20px 0;
            padding: 10px;
            background: #252526;
            color: #d4d4d4;
            border: 1px solid #3e3e42;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>ğŸ” FFmpeg ä¸‹è½½æµ‹è¯•</h1>
    <p>è¿™ä¸ªé¡µé¢ä¼šæµ‹è¯• FFmpeg è½¬æ¢å’Œä¸‹è½½çš„æ¯ä¸€æ­¥</p>
    
    <div>
        <input type="file" id="fileInput" accept=".webm">
        <br>
        <button onclick="testConversion()">å¼€å§‹å®Œæ•´æµ‹è¯•</button>
        <button onclick="clearLog()">æ¸…é™¤æ—¥å¿—</button>
    </div>
    
    <div id="log"></div>

    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
    <script>
        const logDiv = document.getElementById('log');
        const fileInput = document.getElementById('fileInput');
        let ffmpeg = null;

        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `log ${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(div);
            console.log(message);
        }

        function clearLog() {
            logDiv.innerHTML = '';
        }

        async function testConversion() {
            const file = fileInput.files[0];
            if (!file) {
                alert('è¯·å…ˆé€‰æ‹©æ–‡ä»¶');
                return;
            }

            clearLog();
            log('========== å¼€å§‹æµ‹è¯• ==========', 'info');
            log(`é€‰æ‹©çš„æ–‡ä»¶: ${file.name}`, 'info');
            log(`æ–‡ä»¶å¤§å°: ${(file.size / 1024 / 1024).toFixed(2)} MB`, 'info');
            log(`æ–‡ä»¶ç±»å‹: ${file.type}`, 'info');

            try {
                // æ­¥éª¤ 1: åŠ è½½ FFmpeg
                if (!ffmpeg) {
                    log('æ­¥éª¤ 1: åŠ è½½ FFmpeg...', 'info');
                    const { createFFmpeg, fetchFile } = FFmpeg;
                    
                    ffmpeg = createFFmpeg({
                        log: true,
                        progress: ({ ratio }) => {
                            const percent = Math.round(ratio * 100);
                            if (percent % 20 === 0) {
                                log(`è½¬æ¢è¿›åº¦: ${percent}%`, 'info');
                            }
                        }
                    });
                    
                    await ffmpeg.load();
                    log('âœ“ FFmpeg åŠ è½½æˆåŠŸ', 'success');
                }

                // æ­¥éª¤ 2: å†™å…¥æ–‡ä»¶
                log('æ­¥éª¤ 2: å†™å…¥è¾“å…¥æ–‡ä»¶...', 'info');
                const { fetchFile } = FFmpeg;
                ffmpeg.FS('writeFile', 'input.webm', await fetchFile(file));
                log('âœ“ æ–‡ä»¶å†™å…¥æˆåŠŸ', 'success');

                // éªŒè¯æ–‡ä»¶
                const inputData = ffmpeg.FS('readFile', 'input.webm');
                log(`éªŒè¯è¾“å…¥æ–‡ä»¶: ${inputData.length} å­—èŠ‚`, 'info');

                // æ­¥éª¤ 3: è½¬æ¢
                log('æ­¥éª¤ 3: å¼€å§‹è½¬æ¢...', 'info');
                await ffmpeg.run(
                    '-i', 'input.webm',
                    '-c:v', 'libx264',
                    '-preset', 'ultrafast',
                    '-c:a', 'aac',
                    'output.mp4'
                );
                log('âœ“ è½¬æ¢å®Œæˆ', 'success');

                // æ­¥éª¤ 4: è¯»å–è¾“å‡º
                log('æ­¥éª¤ 4: è¯»å–è¾“å‡ºæ–‡ä»¶...', 'info');
                const data = ffmpeg.FS('readFile', 'output.mp4');
                
                log(`è¾“å‡ºæ•°æ®ç±»å‹: ${data.constructor.name}`, 'info');
                log(`è¾“å‡ºæ•°æ®é•¿åº¦: ${data.length} å­—èŠ‚`, 'info');
                log(`è¾“å‡ºæ•°æ®å¤§å°: ${(data.length / 1024 / 1024).toFixed(2)} MB`, 'info');
                
                if (data.length === 0) {
                    throw new Error('è¾“å‡ºæ–‡ä»¶ä¸ºç©ºï¼');
                }
                log('âœ“ è¾“å‡ºæ–‡ä»¶è¯»å–æˆåŠŸ', 'success');

                // æ­¥éª¤ 5: æµ‹è¯•ä¸åŒçš„ä¸‹è½½æ–¹æ³•
                log('æ­¥éª¤ 5: æµ‹è¯•ä¸‹è½½æ–¹æ³•...', 'info');
                
                // æ–¹æ³• 1: ç›´æ¥ä½¿ç”¨ data
                log('æµ‹è¯•æ–¹æ³• 1: new Blob([data])', 'info');
                const blob1 = new Blob([data], { type: 'video/mp4' });
                log(`Blob1 å¤§å°: ${blob1.size} å­—èŠ‚`, blob1.size > 0 ? 'success' : 'error');
                
                // æ–¹æ³• 2: ä½¿ç”¨ data.buffer
                log('æµ‹è¯•æ–¹æ³• 2: new Blob([data.buffer])', 'info');
                const blob2 = new Blob([data.buffer], { type: 'video/mp4' });
                log(`Blob2 å¤§å°: ${blob2.size} å­—èŠ‚`, blob2.size > 0 ? 'success' : 'error');
                
                // æ–¹æ³• 3: ä½¿ç”¨ new Uint8Array
                log('æµ‹è¯•æ–¹æ³• 3: new Blob([new Uint8Array(data)])', 'info');
                const blob3 = new Blob([new Uint8Array(data)], { type: 'video/mp4' });
                log(`Blob3 å¤§å°: ${blob3.size} å­—èŠ‚`, blob3.size > 0 ? 'success' : 'error');

                // é€‰æ‹©æœ€å¤§çš„ blob
                const blobs = [
                    { blob: blob1, name: 'æ–¹æ³•1', size: blob1.size },
                    { blob: blob2, name: 'æ–¹æ³•2', size: blob2.size },
                    { blob: blob3, name: 'æ–¹æ³•3', size: blob3.size }
                ];
                
                blobs.sort((a, b) => b.size - a.size);
                const best = blobs[0];
                
                log(`æœ€ä½³æ–¹æ³•: ${best.name}, å¤§å°: ${best.size} å­—èŠ‚`, 'success');

                // æ­¥éª¤ 6: ä¸‹è½½
                log('æ­¥éª¤ 6: å¼€å§‹ä¸‹è½½...', 'info');
                const url = URL.createObjectURL(best.blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name.replace(/\.webm$/i, '.mp4');
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 1000);
                
                log('âœ“ ä¸‹è½½è§¦å‘æˆåŠŸ', 'success');
                log(`ä¸‹è½½æ–‡ä»¶å: ${a.download}`, 'info');
                log('========== æµ‹è¯•å®Œæˆ ==========', 'success');
                log('è¯·æ£€æŸ¥ä¸‹è½½çš„æ–‡ä»¶æ˜¯å¦æ­£å¸¸', 'info');

                // æ¸…ç†
                ffmpeg.FS('unlink', 'input.webm');
                ffmpeg.FS('unlink', 'output.mp4');

            } catch (error) {
                log('========== é”™è¯¯ ==========', 'error');
                log(`é”™è¯¯ä¿¡æ¯: ${error.message}`, 'error');
                log(`é”™è¯¯å †æ ˆ: ${error.stack}`, 'error');
                console.error(error);
            }
        }

        // é¡µé¢åŠ è½½æ£€æŸ¥
        window.addEventListener('load', () => {
            log('é¡µé¢åŠ è½½å®Œæˆ', 'success');
            log(`FFmpeg åº“: ${typeof FFmpeg !== 'undefined' ? 'å·²åŠ è½½' : 'æœªåŠ è½½'}`, 
                typeof FFmpeg !== 'undefined' ? 'success' : 'error');
        });
    </script>
</body>
</html>
